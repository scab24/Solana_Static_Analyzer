use std::collections::HashMap;
use std::fs;
use std::path::Path;

use crate::analyzer::{Finding, Severity};

/// Generates comprehensive reports from analysis findings (Aderyn style)
pub struct ReportGenerator {
    findings: Vec<Finding>,
    project_path: String,
}

impl ReportGenerator {
    pub fn new(findings: Vec<Finding>, project_path: String) -> Self {
        Self {
            findings,
            project_path,
        }
    }

    /// Generate a clean Markdown report following Aderyn's style
    pub fn generate_markdown_report(&self) -> String {
        let mut report = String::new();
        
        // Header
        report.push_str(&self.generate_header());
        
        // Table of Contents
        report.push_str(&self.generate_table_of_contents());
        
        // Summary Section
        report.push_str(&self.generate_summary());
        
        // Issues by Severity
        report.push_str(&self.generate_issues_by_severity());
        
        report
    }

    /// Save the Markdown report to a file
    pub fn save_markdown_report(&self, output_path: &str) -> Result<(), std::io::Error> {
        let report = self.generate_markdown_report();
        fs::write(output_path, report)?;
        println!("ðŸ“„ Report saved to: {}", output_path);
        Ok(())
    }

    fn generate_header(&self) -> String {
        format!(
            "# Rust Solana Analyzer Report\n\n\
            This report was generated by Rust Solana Analyzer, a static analysis tool for Solana smart contracts. \
            This report is not a substitute for manual audit or security review. It should not be relied upon for any purpose \
            other than to assist in the identification of potential security vulnerabilities.\n"
        )
    }

    fn generate_table_of_contents(&self) -> String {
        let mut toc = String::from("# Table of Contents\n\n");
        
        toc.push_str("- [Summary](#summary)\n");
        toc.push_str("  - [Files Summary](#files-summary)\n");
        toc.push_str("  - [Files Details](#files-details)\n");
        toc.push_str("  - [Issue Summary](#issue-summary)\n");

        // Add sections for each severity level that has findings
        let severity_counts = self.get_severity_counts();
        
        if severity_counts.get(&Severity::High).unwrap_or(&0) > &0 {
            toc.push_str("- [High Issues](#high-issues)\n");
        }
        if severity_counts.get(&Severity::Medium).unwrap_or(&0) > &0 {
            toc.push_str("- [Medium Issues](#medium-issues)\n");
        }
        if severity_counts.get(&Severity::Low).unwrap_or(&0) > &0 {
            toc.push_str("- [Low Issues](#low-issues)\n");
        }
        if severity_counts.get(&Severity::Informational).unwrap_or(&0) > &0 {
            toc.push_str("- [Informational Issues](#informational-issues)\n");
        }

        toc.push_str("\n\n");
        toc
    }

    fn generate_summary(&self) -> String {
        let mut summary = String::from("# Summary\n\n");
        
        // Files Summary
        summary.push_str("## Files Summary\n\n");
        summary.push_str("| Key | Value |\n");
        summary.push_str("| --- | --- |\n");
        
        let file_count = self.get_unique_file_count();
        summary.push_str(&format!("| .rs Files | {} |\n", file_count));
        summary.push_str(&format!("| Total Issues | {} |\n\n", self.findings.len()));

        // Files Details
        summary.push_str("## Files Details\n\n");
        summary.push_str("| Filepath | Issues |\n");
        summary.push_str("| --- | --- |\n");
        
        let file_counts = self.get_file_issue_counts();
        for (file, count) in file_counts {
            let display_file = file.strip_prefix(&self.project_path)
                .unwrap_or(&file)
                .trim_start_matches('/');
            summary.push_str(&format!("| {} | {} |\n", display_file, count));
        }
        summary.push_str(&format!("| **Total** | **{}** |\n\n", self.findings.len()));

        // Issue Summary
        summary.push_str("## Issue Summary\n\n");
        summary.push_str("| Category | No. of Issues |\n");
        summary.push_str("| --- | --- |\n");
        
        let severity_counts = self.get_severity_counts();
        summary.push_str(&format!("| High | {} |\n", severity_counts.get(&Severity::High).unwrap_or(&0)));
        summary.push_str(&format!("| Medium | {} |\n", severity_counts.get(&Severity::Medium).unwrap_or(&0)));
        summary.push_str(&format!("| Low | {} |\n", severity_counts.get(&Severity::Low).unwrap_or(&0)));
        summary.push_str(&format!("| Informational | {} |\n\n", severity_counts.get(&Severity::Informational).unwrap_or(&0)));

        summary
    }

    fn generate_issues_by_severity(&self) -> String {
        let mut issues = String::new();
        
        let severity_counts = self.get_severity_counts();
        
        // High Issues
        if severity_counts.get(&Severity::High).unwrap_or(&0) > &0 {
            issues.push_str("# High Issues\n\n");
            issues.push_str(&self.generate_severity_section(&Severity::High));
        }
        
        // Medium Issues
        if severity_counts.get(&Severity::Medium).unwrap_or(&0) > &0 {
            issues.push_str("# Medium Issues\n\n");
            issues.push_str(&self.generate_severity_section(&Severity::Medium));
        }
        
        // Low Issues
        if severity_counts.get(&Severity::Low).unwrap_or(&0) > &0 {
            issues.push_str("# Low Issues\n\n");
            issues.push_str(&self.generate_severity_section(&Severity::Low));
        }
        
        // Informational Issues
        if severity_counts.get(&Severity::Informational).unwrap_or(&0) > &0 {
            issues.push_str("# Informational Issues\n\n");
            issues.push_str(&self.generate_severity_section(&Severity::Informational));
        }
        
        issues
    }

    fn generate_severity_section(&self, severity: &Severity) -> String {
        let mut section = String::new();
        
        // Group findings by title (extract title from description)
        let mut grouped_findings: HashMap<String, (String, Vec<&Finding>)> = HashMap::new();
        for finding in &self.findings {
            if &finding.severity == severity {
                let (title, description) = self.extract_title_and_description(&finding.description);
                grouped_findings.entry(title.clone())
                    .or_insert_with(|| (description, Vec::new()))
                    .1.push(finding);
            }
        }

        let mut issue_counter = 1;
        for (title, (description, findings)) in grouped_findings {
            let severity_prefix = match severity {
                Severity::High => "H",
                Severity::Medium => "M", 
                Severity::Low => "L",
                Severity::Informational => "I",
            };
            
            // Title (concise)
            section.push_str(&format!("## {}-{}: {}\n\n", severity_prefix, issue_counter, title));
            
            // Description (detailed explanation)
            section.push_str(&format!("{}\n\n", description));
            
            // Instances
            section.push_str(&format!("<details><summary>{} Found Instance{}</summary>\n\n", 
                findings.len(), 
                if findings.len() == 1 { "" } else { "s" }
            ));
            
            for finding in findings {
                let display_location = finding.location.file.strip_prefix(&self.project_path)
                    .unwrap_or(&finding.location.file)
                    .trim_start_matches('/');
                
                section.push_str(&format!("- Found in {} [Line: {}]\n\n", display_location, finding.location.line));
                
                if let Some(ref code) = finding.code_snippet {
                    section.push_str("\t```rust\n");
                    for line in code.lines() {
                        section.push_str(&format!("\t{}\n", line));
                    }
                    section.push_str("\t```\n\n");
                }
            }
            
            section.push_str("</details>\n\n\n\n");
            issue_counter += 1;
        }
        
        section
    }

    /// Extract title and description from finding description
    /// Format: "Title. Description with more details."
    fn extract_title_and_description(&self, full_description: &str) -> (String, String) {
        // Find the first sentence as title
        if let Some(first_dot) = full_description.find(". ") {
            let title = full_description[..first_dot].trim().to_string();
            let description = full_description[first_dot + 2..].trim().to_string();
            (title, description)
        } else {
            // If no clear separation, use a simplified approach
            let parts: Vec<&str> = full_description.splitn(2, " has ").collect();
            if parts.len() == 2 {
                let title = format!("{} Issue", parts[0]);
                let description = format!("This {} has {}. Consider reviewing and fixing this issue.", parts[0].to_lowercase(), parts[1]);
                (title, description)
            } else {
                // Fallback: use first part as title, rest as description
                let words: Vec<&str> = full_description.split_whitespace().collect();
                if words.len() > 6 {
                    let title = words[..6].join(" ");
                    let description = words[6..].join(" ");
                    (title, description)
                } else {
                    (full_description.to_string(), "Review and fix this issue.".to_string())
                }
            }
        }
    }

    fn get_severity_counts(&self) -> HashMap<Severity, usize> {
        let mut counts = HashMap::new();
        for finding in &self.findings {
            *counts.entry(finding.severity.clone()).or_insert(0) += 1;
        }
        counts
    }

    fn get_unique_file_count(&self) -> usize {
        let mut files = std::collections::HashSet::new();
        for finding in &self.findings {
            files.insert(&finding.location.file);
        }
        files.len()
    }

    fn get_file_issue_counts(&self) -> Vec<(String, usize)> {
        let mut file_counts: HashMap<String, usize> = HashMap::new();
        for finding in &self.findings {
            *file_counts.entry(finding.location.file.clone()).or_insert(0) += 1;
        }
        
        let mut sorted_counts: Vec<(String, usize)> = file_counts.into_iter().collect();
        sorted_counts.sort_by(|a, b| a.0.cmp(&b.0));
        sorted_counts
    }
}
